#include <iostream>
#include <bitset>

using namespace std;

void main()
{
	/*
	# 이진수와 친해져보기

	정수의 경우 bitset을 쓰면 쉽다.
	단 bitset은 소수점 아래에 숫자가 있는 실수를 쓰려면 복잡해 지는 듯 하다
	그러니 직접 하는 법도 알아보자

	십진수가 소수점 위면 2로 나눠서 계산
	십진수가 소수점 아래면 2를 곱해서 계산

	소수점 이상은 떼어내서 bitset 쓰고 소수점 아래는 직접 해도 될듯

	# 소수점 위는 아래의 방식으로 해결
	2로 나눈 나머지를 구하고, 2로 나누기를 반복
	나온 결과를 아래에서 위로 읽으면 된다.
	예를들어 10진수 4를 2진수로 변환하려면
	4%2는 0, 4를 2로 나눠주고 => 0
	2%2는 0, 2를 2로 나눠주고 => 0
	1%2는 1, 1을 2로 나눠주고 => 1
	끝났으니 역순으로 읽으면 100이 된다.

	# 소수점 아래는 아래의 방식으로 해결
	2를 곱한 후 소수점 위 값을 구하고, 그 값을 빼주기를 반복
	나온 결과를 위에서 아래로 읽으면 된다.
	예를 들어 0.625를 2진수로 변환하려면
	0.625에 2를 곱해서 1.25, 여기서 소수점 위의 수 1을 빼줌 => 1
	다시 0.25에 2를 곱해서 0.5, 소수점 위의 0을 빼줌 => 0
	다시 0.5에 2를 곱해서 1.0, 소수점 위의 1을 빼줌 => 1
	숫자가 0이 되었으니 끝
	결과는 오른쪽에 나온 숫자들을 위에서 아래로 읽으면 됨
	이진수 0.101이 십진수 0.625인 셈

	case 1 = 10진수 정수를 2진수로 변환하기
	case 2 = 10진수 실수를 2진수로 변환하기
	case 3 = 2진수를 10진수로 변환하기
	*/

	/*
	case 1 = 10진수 정수를 2진수로 변환하기
	*/

	// bitset 사용방식
	int n2bit = 5;
	cout << "5는 2진수로 : " << bitset<8 * sizeof(n2bit)>(n2bit) << endl;

	// 직접 구현 방식
	int result = 0;	
	for(int i=1; n2bit >= 1; i *= 10) {
		result = (n2bit % 2) * i + result;
		n2bit /= 2;
	}
	cout << "5는 2진수로 : " << result << endl;

	/*
	case 2 = 10진수 실수를 2진수로 변환하기
	소수점 윗부분은 떼어내서 bitset을 써도 되고, 직접 해도 된다.
	여기선 소수점 아래 부분만
	*/
	double d2bit = 0.625;
	cout << "0.625는 2진수로 0.";
	while (d2bit != 0)
	{
		d2bit *= 2;
		cout << (int)d2bit;

		if (d2bit >= 1) d2bit -= 1;
	}
	cout << endl;

	/*
	case 3 = 2진수를 10진수로 변환하기
	*/

	// bitset 사용방식
	// bitset 객체에 넣고 to_ulong() 하면 끝
	int num1 = 10;
	int num2 = 15;

	bitset<32> b1(num1);  // b1 = 1010
	bitset<32> b2(num2);  // b2 = 1111

	cout << b1 << endl; // 출력시 000000.....1010
	cout << b1.to_ulong() << endl; // 출력시 10진수 10
	
	// 직접 구현 방식
	result = 0;
	int bit = 100; // 2진수 100이니 10진수로 4
	for (int j = 0; bit >= 1; j++) {
		result += (bit % 10) * pow(2, j);
		bit /= 10;
	}
	cout << "이진수 100은 10진수로 " << result << endl;
}